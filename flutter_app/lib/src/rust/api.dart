// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`

/// Initialize the core engine
/// Call this once when the app starts
Future<void> initCore(
        {required String dbPath, required String encryptionKey}) =>
    RustLib.instance.api
        .crateApiInitCore(dbPath: dbPath, encryptionKey: encryptionKey);

/// Generate new identity keys
/// Call this during signup
Future<KeyBundleDto> generateIdentityKeys() =>
    RustLib.instance.api.crateApiGenerateIdentityKeys();

/// Get the public key bundle (to upload to server)
Future<PublicKeyBundleDto> getPublicKeyBundle() =>
    RustLib.instance.api.crateApiGetPublicKeyBundle();

/// Initialize a session with a recipient
/// Call this before sending messages to a new contact
Future<void> initSession(
        {required String recipientId,
        required List<int> identityPublicKey,
        required List<int> signedPrekey,
        required List<int> signature,
        Uint8List? oneTimePrekey}) =>
    RustLib.instance.api.crateApiInitSession(
        recipientId: recipientId,
        identityPublicKey: identityPublicKey,
        signedPrekey: signedPrekey,
        signature: signature,
        oneTimePrekey: oneTimePrekey);

/// Check if we have a session with a recipient
Future<bool> hasSession({required String recipientId}) =>
    RustLib.instance.api.crateApiHasSession(recipientId: recipientId);

/// Encrypt a message for a recipient
Future<Uint8List> encryptMessage(
        {required String recipientId, required String plaintext}) =>
    RustLib.instance.api
        .crateApiEncryptMessage(recipientId: recipientId, plaintext: plaintext);

/// Decrypt a message from a sender
Future<String> decryptMessage(
        {required String senderId, required List<int> ciphertext}) =>
    RustLib.instance.api
        .crateApiDecryptMessage(senderId: senderId, ciphertext: ciphertext);

/// Public key bundle (to share with server/contacts)
class KeyBundleDto {
  final Uint8List identityPublicKey;
  final Uint8List signedPrekey;
  final Uint8List signature;

  const KeyBundleDto({
    required this.identityPublicKey,
    required this.signedPrekey,
    required this.signature,
  });

  @override
  int get hashCode =>
      identityPublicKey.hashCode ^ signedPrekey.hashCode ^ signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyBundleDto &&
          runtimeType == other.runtimeType &&
          identityPublicKey == other.identityPublicKey &&
          signedPrekey == other.signedPrekey &&
          signature == other.signature;
}

/// Minimal public key bundle for session init
class PublicKeyBundleDto {
  final Uint8List identityPublicKey;
  final Uint8List signedPrekey;
  final Uint8List signature;
  final Uint8List? oneTimePrekey;

  const PublicKeyBundleDto({
    required this.identityPublicKey,
    required this.signedPrekey,
    required this.signature,
    this.oneTimePrekey,
  });

  @override
  int get hashCode =>
      identityPublicKey.hashCode ^
      signedPrekey.hashCode ^
      signature.hashCode ^
      oneTimePrekey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicKeyBundleDto &&
          runtimeType == other.runtimeType &&
          identityPublicKey == other.identityPublicKey &&
          signedPrekey == other.signedPrekey &&
          signature == other.signature &&
          oneTimePrekey == other.oneTimePrekey;
}
